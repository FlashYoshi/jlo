package java.util.concurrent;
public class SynchronousQueue<E extends java.lang.Object> extends java.util.AbstractQueue<E> implements java.util.concurrent.BlockingQueue<E>, java.io.Serializable {
   public  SynchronousQueue(){}
   public  SynchronousQueue(boolean a_r_g_u_m_e_n_t_0){}
  public native void put(E a_r_g_u_m_e_n_t_0)  throws java.lang.InterruptedException;
  public native void clear() ;
  public native boolean isEmpty() ;
  public native boolean contains(java.lang.Object a_r_g_u_m_e_n_t_0) ;
  public native int size() ;
  public native java.lang.Object[] toArray() ;
  public native <T extends java.lang.Object>T[] toArray(T[] a_r_g_u_m_e_n_t_0) ;
  public native java.util.Iterator<E> iterator() ;
  public native boolean remove(java.lang.Object a_r_g_u_m_e_n_t_0) ;
  public native boolean containsAll(java.util.Collection<? extends java.lang.Object> a_r_g_u_m_e_n_t_0) ;
  public native boolean removeAll(java.util.Collection<? extends java.lang.Object> a_r_g_u_m_e_n_t_0) ;
  public native boolean retainAll(java.util.Collection<? extends java.lang.Object> a_r_g_u_m_e_n_t_0) ;
  public native E poll() ;
  public native E poll(long a_r_g_u_m_e_n_t_0, java.util.concurrent.TimeUnit a_r_g_u_m_e_n_t_1)  throws java.lang.InterruptedException;
  public native E peek() ;
  public native boolean offer(E a_r_g_u_m_e_n_t_0, long a_r_g_u_m_e_n_t_1, java.util.concurrent.TimeUnit a_r_g_u_m_e_n_t_2)  throws java.lang.InterruptedException;
  public native boolean offer(E a_r_g_u_m_e_n_t_0) ;
  public native E take()  throws java.lang.InterruptedException;
  public native int remainingCapacity() ;
  public native int drainTo(java.util.Collection<? super E> a_r_g_u_m_e_n_t_0, int a_r_g_u_m_e_n_t_1) ;
  public native int drainTo(java.util.Collection<? super E> a_r_g_u_m_e_n_t_0) ;
  static final int NCPUS;
  static final int maxTimedSpins;
  static final int maxUntimedSpins;
  static final long spinForTimeoutThreshold;
  static class FifoWaitQueue extends java.util.concurrent.SynchronousQueue.WaitQueue {
      FifoWaitQueue(){}
  }
  static class LifoWaitQueue extends java.util.concurrent.SynchronousQueue.WaitQueue {
      LifoWaitQueue(){}
  }
  static class WaitQueue extends java.lang.Object implements java.io.Serializable {
      WaitQueue(){}
  }
  static class EmptyIterator<E extends java.lang.Object> extends java.lang.Object implements java.util.Iterator<E> {
      EmptyIterator(){}
    public native boolean hasNext() ;
    public native E next() ;
    public native void remove() ;
  }
  static final class TransferQueue extends java.util.concurrent.SynchronousQueue.Transferer {
      TransferQueue(){}
    native java.lang.Object transfer(java.lang.Object a_r_g_u_m_e_n_t_0, boolean a_r_g_u_m_e_n_t_1, long a_r_g_u_m_e_n_t_2) ;
    native void clean(java.util.concurrent.SynchronousQueue.TransferQueue.QNode a_r_g_u_m_e_n_t_0, java.util.concurrent.SynchronousQueue.TransferQueue.QNode a_r_g_u_m_e_n_t_1) ;
    native void advanceHead(java.util.concurrent.SynchronousQueue.TransferQueue.QNode a_r_g_u_m_e_n_t_0, java.util.concurrent.SynchronousQueue.TransferQueue.QNode a_r_g_u_m_e_n_t_1) ;
    native void advanceTail(java.util.concurrent.SynchronousQueue.TransferQueue.QNode a_r_g_u_m_e_n_t_0, java.util.concurrent.SynchronousQueue.TransferQueue.QNode a_r_g_u_m_e_n_t_1) ;
    native boolean casCleanMe(java.util.concurrent.SynchronousQueue.TransferQueue.QNode a_r_g_u_m_e_n_t_0, java.util.concurrent.SynchronousQueue.TransferQueue.QNode a_r_g_u_m_e_n_t_1) ;
    native java.lang.Object awaitFulfill(java.util.concurrent.SynchronousQueue.TransferQueue.QNode a_r_g_u_m_e_n_t_0, java.lang.Object a_r_g_u_m_e_n_t_1, boolean a_r_g_u_m_e_n_t_2, long a_r_g_u_m_e_n_t_3) ;
    transient volatile java.util.concurrent.SynchronousQueue.TransferQueue.QNode head;
    transient volatile java.util.concurrent.SynchronousQueue.TransferQueue.QNode tail;
    transient volatile java.util.concurrent.SynchronousQueue.TransferQueue.QNode cleanMe;
    static final java.util.concurrent.atomic.AtomicReferenceFieldUpdater<java.util.concurrent.SynchronousQueue.TransferQueue,java.util.concurrent.SynchronousQueue.TransferQueue.QNode> headUpdater;
    static final java.util.concurrent.atomic.AtomicReferenceFieldUpdater<java.util.concurrent.SynchronousQueue.TransferQueue,java.util.concurrent.SynchronousQueue.TransferQueue.QNode> tailUpdater;
    static final java.util.concurrent.atomic.AtomicReferenceFieldUpdater<java.util.concurrent.SynchronousQueue.TransferQueue,java.util.concurrent.SynchronousQueue.TransferQueue.QNode> cleanMeUpdater;
    static final class QNode extends java.lang.Object {
        QNode(java.lang.Object a_r_g_u_m_e_n_t_0, boolean a_r_g_u_m_e_n_t_1){}
      native boolean isCancelled() ;
      native boolean casNext(java.util.concurrent.SynchronousQueue.TransferQueue.QNode a_r_g_u_m_e_n_t_0, java.util.concurrent.SynchronousQueue.TransferQueue.QNode a_r_g_u_m_e_n_t_1) ;
      native boolean casItem(java.lang.Object a_r_g_u_m_e_n_t_0, java.lang.Object a_r_g_u_m_e_n_t_1) ;
      native void tryCancel(java.lang.Object a_r_g_u_m_e_n_t_0) ;
      native boolean isOffList() ;
      volatile java.util.concurrent.SynchronousQueue.TransferQueue.QNode next;
      volatile java.lang.Object item;
      volatile java.lang.Thread waiter;
      final boolean isData;
      static final java.util.concurrent.atomic.AtomicReferenceFieldUpdater<java.util.concurrent.SynchronousQueue.TransferQueue.QNode,java.util.concurrent.SynchronousQueue.TransferQueue.QNode> nextUpdater;
      static final java.util.concurrent.atomic.AtomicReferenceFieldUpdater<java.util.concurrent.SynchronousQueue.TransferQueue.QNode,java.lang.Object> itemUpdater;
    }
  }
  static final class TransferStack extends java.util.concurrent.SynchronousQueue.Transferer {
      TransferStack(){}
    native java.lang.Object transfer(java.lang.Object a_r_g_u_m_e_n_t_0, boolean a_r_g_u_m_e_n_t_1, long a_r_g_u_m_e_n_t_2) ;
    native void clean(java.util.concurrent.SynchronousQueue.TransferStack.SNode a_r_g_u_m_e_n_t_0) ;
    native boolean casHead(java.util.concurrent.SynchronousQueue.TransferStack.SNode a_r_g_u_m_e_n_t_0, java.util.concurrent.SynchronousQueue.TransferStack.SNode a_r_g_u_m_e_n_t_1) ;
    native java.util.concurrent.SynchronousQueue.TransferStack.SNode awaitFulfill(java.util.concurrent.SynchronousQueue.TransferStack.SNode a_r_g_u_m_e_n_t_0, boolean a_r_g_u_m_e_n_t_1, long a_r_g_u_m_e_n_t_2) ;
    static native boolean isFulfilling(int a_r_g_u_m_e_n_t_0) ;
    static native java.util.concurrent.SynchronousQueue.TransferStack.SNode snode(java.util.concurrent.SynchronousQueue.TransferStack.SNode a_r_g_u_m_e_n_t_0, java.lang.Object a_r_g_u_m_e_n_t_1, java.util.concurrent.SynchronousQueue.TransferStack.SNode a_r_g_u_m_e_n_t_2, int a_r_g_u_m_e_n_t_3) ;
    native boolean shouldSpin(java.util.concurrent.SynchronousQueue.TransferStack.SNode a_r_g_u_m_e_n_t_0) ;
    static final int REQUEST;
    static final int DATA;
    static final int FULFILLING;
    volatile java.util.concurrent.SynchronousQueue.TransferStack.SNode head;
    static final java.util.concurrent.atomic.AtomicReferenceFieldUpdater<java.util.concurrent.SynchronousQueue.TransferStack,java.util.concurrent.SynchronousQueue.TransferStack.SNode> headUpdater;
    static final class SNode extends java.lang.Object {
        SNode(java.lang.Object a_r_g_u_m_e_n_t_0){}
      native boolean isCancelled() ;
      native boolean casNext(java.util.concurrent.SynchronousQueue.TransferStack.SNode a_r_g_u_m_e_n_t_0, java.util.concurrent.SynchronousQueue.TransferStack.SNode a_r_g_u_m_e_n_t_1) ;
      native void tryCancel() ;
      native boolean tryMatch(java.util.concurrent.SynchronousQueue.TransferStack.SNode a_r_g_u_m_e_n_t_0) ;
      volatile java.util.concurrent.SynchronousQueue.TransferStack.SNode next;
      volatile java.util.concurrent.SynchronousQueue.TransferStack.SNode match;
      volatile java.lang.Thread waiter;
      java.lang.Object item;
      int mode;
      static final java.util.concurrent.atomic.AtomicReferenceFieldUpdater<java.util.concurrent.SynchronousQueue.TransferStack.SNode,java.util.concurrent.SynchronousQueue.TransferStack.SNode> nextUpdater;
      static final java.util.concurrent.atomic.AtomicReferenceFieldUpdater<java.util.concurrent.SynchronousQueue.TransferStack.SNode,java.util.concurrent.SynchronousQueue.TransferStack.SNode> matchUpdater;
    }
  }
  static abstract class Transferer extends java.lang.Object {
      Transferer(){}
    abstract java.lang.Object transfer(java.lang.Object a_r_g_u_m_e_n_t_0, boolean a_r_g_u_m_e_n_t_1, long a_r_g_u_m_e_n_t_2) ;
  }
}