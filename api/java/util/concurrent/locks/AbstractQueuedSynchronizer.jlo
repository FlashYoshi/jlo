package java.util.concurrent.locks;
public abstract class AbstractQueuedSynchronizer extends java.util.concurrent.locks.AbstractOwnableSynchronizer implements java.io.Serializable {
   protected  AbstractQueuedSynchronizer(){}
  public native java.lang.String toString() ;
  protected final native int getState() ;
  protected final native void setState(int a_r_g_u_m_e_n_t_0) ;
  public final native void acquire(int a_r_g_u_m_e_n_t_0) ;
  public final native boolean release(int a_r_g_u_m_e_n_t_0) ;
  public final native boolean hasQueuedThreads() ;
  public final native int getQueueLength() ;
  public final native java.util.Collection<java.lang.Thread> getQueuedThreads() ;
  public final native boolean hasWaiters(java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject a_r_g_u_m_e_n_t_0) ;
  public final native int getWaitQueueLength(java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject a_r_g_u_m_e_n_t_0) ;
  public final native java.util.Collection<java.lang.Thread> getWaitingThreads(java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject a_r_g_u_m_e_n_t_0) ;
  public final native void acquireInterruptibly(int a_r_g_u_m_e_n_t_0)  throws java.lang.InterruptedException;
  public final native boolean tryAcquireNanos(int a_r_g_u_m_e_n_t_0, long a_r_g_u_m_e_n_t_1)  throws java.lang.InterruptedException;
  protected native boolean isHeldExclusively() ;
  public final native boolean isQueued(java.lang.Thread a_r_g_u_m_e_n_t_0) ;
  protected native boolean tryAcquire(int a_r_g_u_m_e_n_t_0) ;
  protected final native boolean compareAndSetState(int a_r_g_u_m_e_n_t_0, int a_r_g_u_m_e_n_t_1) ;
  protected native boolean tryRelease(int a_r_g_u_m_e_n_t_0) ;
  final native boolean acquireQueued(java.util.concurrent.locks.AbstractQueuedSynchronizer.Node a_r_g_u_m_e_n_t_0, int a_r_g_u_m_e_n_t_1) ;
  protected native int tryAcquireShared(int a_r_g_u_m_e_n_t_0) ;
  protected native boolean tryReleaseShared(int a_r_g_u_m_e_n_t_0) ;
  public final native void acquireShared(int a_r_g_u_m_e_n_t_0) ;
  public final native void acquireSharedInterruptibly(int a_r_g_u_m_e_n_t_0)  throws java.lang.InterruptedException;
  public final native boolean tryAcquireSharedNanos(int a_r_g_u_m_e_n_t_0, long a_r_g_u_m_e_n_t_1)  throws java.lang.InterruptedException;
  public final native boolean releaseShared(int a_r_g_u_m_e_n_t_0) ;
  public final native boolean hasContended() ;
  public final native java.lang.Thread getFirstQueuedThread() ;
  final native boolean apparentlyFirstQueuedIsExclusive() ;
  final native boolean isFirst(java.lang.Thread a_r_g_u_m_e_n_t_0) ;
  final native boolean fullIsFirst(java.lang.Thread a_r_g_u_m_e_n_t_0) ;
  public final native java.util.Collection<java.lang.Thread> getExclusiveQueuedThreads() ;
  public final native java.util.Collection<java.lang.Thread> getSharedQueuedThreads() ;
  final native boolean isOnSyncQueue(java.util.concurrent.locks.AbstractQueuedSynchronizer.Node a_r_g_u_m_e_n_t_0) ;
  final native boolean transferForSignal(java.util.concurrent.locks.AbstractQueuedSynchronizer.Node a_r_g_u_m_e_n_t_0) ;
  final native boolean transferAfterCancelledWait(java.util.concurrent.locks.AbstractQueuedSynchronizer.Node a_r_g_u_m_e_n_t_0) ;
  final native int fullyRelease(java.util.concurrent.locks.AbstractQueuedSynchronizer.Node a_r_g_u_m_e_n_t_0) ;
  public final native boolean owns(java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject a_r_g_u_m_e_n_t_0) ;
  static final long spinForTimeoutThreshold;
  public class ConditionObject extends java.lang.Object implements java.util.concurrent.locks.Condition, java.io.Serializable {
     public  ConditionObject(java.util.concurrent.locks.AbstractQueuedSynchronizer a_r_g_u_m_e_n_t_0){}
    protected final native boolean hasWaiters() ;
    protected final native int getWaitQueueLength() ;
    protected final native java.util.Collection<java.lang.Thread> getWaitingThreads() ;
    final native boolean isOwnedBy(java.util.concurrent.locks.AbstractQueuedSynchronizer a_r_g_u_m_e_n_t_0) ;
    public final native boolean await(long a_r_g_u_m_e_n_t_0, java.util.concurrent.TimeUnit a_r_g_u_m_e_n_t_1)  throws java.lang.InterruptedException;
    public final native void await()  throws java.lang.InterruptedException;
    public final native void signal() ;
    public final native void signalAll() ;
    public final native void awaitUninterruptibly() ;
    public final native long awaitNanos(long a_r_g_u_m_e_n_t_0)  throws java.lang.InterruptedException;
    public final native boolean awaitUntil(java.util.Date a_r_g_u_m_e_n_t_0)  throws java.lang.InterruptedException;
    final java.util.concurrent.locks.AbstractQueuedSynchronizer this$0;
  }
  static final class Node extends java.lang.Object {
      Node(){}
      Node(java.lang.Thread a_r_g_u_m_e_n_t_0, java.util.concurrent.locks.AbstractQueuedSynchronizer.Node a_r_g_u_m_e_n_t_1){}
      Node(java.lang.Thread a_r_g_u_m_e_n_t_0, int a_r_g_u_m_e_n_t_1){}
    final native boolean isShared() ;
    final native java.util.concurrent.locks.AbstractQueuedSynchronizer.Node predecessor()  throws java.lang.NullPointerException;
    static final int CANCELLED;
    static final int SIGNAL;
    static final int CONDITION;
    static final java.util.concurrent.locks.AbstractQueuedSynchronizer.Node SHARED;
    static final java.util.concurrent.locks.AbstractQueuedSynchronizer.Node EXCLUSIVE;
    volatile int waitStatus;
    volatile java.util.concurrent.locks.AbstractQueuedSynchronizer.Node prev;
    volatile java.util.concurrent.locks.AbstractQueuedSynchronizer.Node next;
    volatile java.lang.Thread thread;
    java.util.concurrent.locks.AbstractQueuedSynchronizer.Node nextWaiter;
  }
}