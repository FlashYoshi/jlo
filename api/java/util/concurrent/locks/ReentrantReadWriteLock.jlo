package java.util.concurrent.locks;
public class ReentrantReadWriteLock extends java.lang.Object implements java.util.concurrent.locks.ReadWriteLock, java.io.Serializable {
   public  ReentrantReadWriteLock(boolean a_r_g_u_m_e_n_t_0){}
   public  ReentrantReadWriteLock(){}
  public native java.lang.String toString() ;
  protected native java.lang.Thread getOwner() ;
  public final native boolean isFair() ;
  public final native boolean hasQueuedThreads() ;
  public final native boolean hasQueuedThread(java.lang.Thread a_r_g_u_m_e_n_t_0) ;
  public final native int getQueueLength() ;
  protected native java.util.Collection<java.lang.Thread> getQueuedThreads() ;
  public native boolean hasWaiters(java.util.concurrent.locks.Condition a_r_g_u_m_e_n_t_0) ;
  public native int getWaitQueueLength(java.util.concurrent.locks.Condition a_r_g_u_m_e_n_t_0) ;
  protected native java.util.Collection<java.lang.Thread> getWaitingThreads(java.util.concurrent.locks.Condition a_r_g_u_m_e_n_t_0) ;
  public native java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock writeLock() ;
  public native java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock readLock() ;
  public native int getReadLockCount() ;
  public native boolean isWriteLocked() ;
  public native boolean isWriteLockedByCurrentThread() ;
  public native int getWriteHoldCount() ;
  public native int getReadHoldCount() ;
  protected native java.util.Collection<java.lang.Thread> getQueuedWriterThreads() ;
  protected native java.util.Collection<java.lang.Thread> getQueuedReaderThreads() ;
  public static class WriteLock extends java.lang.Object implements java.util.concurrent.locks.Lock, java.io.Serializable {
     protected  WriteLock(java.util.concurrent.locks.ReentrantReadWriteLock a_r_g_u_m_e_n_t_0){}
    public native void lock() ;
    public native java.lang.String toString() ;
    public native void unlock() ;
    public native void lockInterruptibly()  throws java.lang.InterruptedException;
    public native boolean tryLock(long a_r_g_u_m_e_n_t_0, java.util.concurrent.TimeUnit a_r_g_u_m_e_n_t_1)  throws java.lang.InterruptedException;
    public native boolean tryLock() ;
    public native java.util.concurrent.locks.Condition newCondition() ;
    public native int getHoldCount() ;
    public native boolean isHeldByCurrentThread() ;
  }
  public static class ReadLock extends java.lang.Object implements java.util.concurrent.locks.Lock, java.io.Serializable {
     protected  ReadLock(java.util.concurrent.locks.ReentrantReadWriteLock a_r_g_u_m_e_n_t_0){}
    public native void lock() ;
    public native java.lang.String toString() ;
    public native void unlock() ;
    public native void lockInterruptibly()  throws java.lang.InterruptedException;
    public native boolean tryLock() ;
    public native boolean tryLock(long a_r_g_u_m_e_n_t_0, java.util.concurrent.TimeUnit a_r_g_u_m_e_n_t_1)  throws java.lang.InterruptedException;
    public native java.util.concurrent.locks.Condition newCondition() ;
  }
  static final class FairSync extends java.util.concurrent.locks.ReentrantReadWriteLock.Sync {
      FairSync(){}
    final native boolean readerShouldBlock(java.lang.Thread a_r_g_u_m_e_n_t_0) ;
    final native boolean writerShouldBlock(java.lang.Thread a_r_g_u_m_e_n_t_0) ;
  }
  static final class NonfairSync extends java.util.concurrent.locks.ReentrantReadWriteLock.Sync {
      NonfairSync(){}
    final native boolean readerShouldBlock(java.lang.Thread a_r_g_u_m_e_n_t_0) ;
    final native boolean writerShouldBlock(java.lang.Thread a_r_g_u_m_e_n_t_0) ;
  }
  static abstract class Sync extends java.util.concurrent.locks.AbstractQueuedSynchronizer {
      Sync(){}
    final native java.lang.Thread getOwner() ;
    final native java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject newCondition() ;
    protected final native boolean isHeldExclusively() ;
    protected final native boolean tryAcquire(int a_r_g_u_m_e_n_t_0) ;
    protected final native boolean tryRelease(int a_r_g_u_m_e_n_t_0) ;
    protected final native int tryAcquireShared(int a_r_g_u_m_e_n_t_0) ;
    protected final native boolean tryReleaseShared(int a_r_g_u_m_e_n_t_0) ;
    final native int getCount() ;
    final native int getReadLockCount() ;
    final native boolean isWriteLocked() ;
    final native int getWriteHoldCount() ;
    final native int getReadHoldCount() ;
    static native int exclusiveCount(int a_r_g_u_m_e_n_t_0) ;
    static native int sharedCount(int a_r_g_u_m_e_n_t_0) ;
    abstract boolean readerShouldBlock(java.lang.Thread a_r_g_u_m_e_n_t_0) ;
    abstract boolean writerShouldBlock(java.lang.Thread a_r_g_u_m_e_n_t_0) ;
    final native int fullTryAcquireShared(java.lang.Thread a_r_g_u_m_e_n_t_0) ;
    final native boolean tryWriteLock() ;
    final native boolean tryReadLock() ;
    static final int SHARED_SHIFT;
    static final int SHARED_UNIT;
    static final int MAX_COUNT;
    static final int EXCLUSIVE_MASK;
    transient java.util.concurrent.locks.ReentrantReadWriteLock.Sync.ThreadLocalHoldCounter readHolds;
    transient java.util.concurrent.locks.ReentrantReadWriteLock.Sync.HoldCounter cachedHoldCounter;
    static final class ThreadLocalHoldCounter extends java.lang.ThreadLocal<java.util.concurrent.locks.ReentrantReadWriteLock.Sync.HoldCounter> {
        ThreadLocalHoldCounter(){}
      public native java.util.concurrent.locks.ReentrantReadWriteLock.Sync.HoldCounter initialValue() ;
    }
    static final class HoldCounter extends java.lang.Object {
        HoldCounter(){}
      native int tryDecrement() ;
      int count;
      final long tid;
    }
  }
}